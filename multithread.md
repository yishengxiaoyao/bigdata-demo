# 多线程
## 线程 vs 进程
### 进程
进程是指一段正在执行的程序。线程是操作系统进行资源分配和调度的一个基本单元。一个进程可以拥有多个线程，多个线程之间共享程序的内存空间及以自我

### 线程
线程是指程序在执行过程中,能够执行程序代码的一个执行单元。线程是程序的最小执行单元。

引入线程的目的:充分利用CPU资源、使其可以并行处理多个任务、减少时间消耗、提高效率。

一个程序至少有一个进程,一个进程又至少包含一个线程,进程中的多个线程共享进程资源。

#### 线程的分类
>* 用户线程User Thread:一般都是程序中创建的线程。
>* 守护线程Demon Thread:为用户线程服务的线程,当所有用户线程结束时才停止,例如JVM的垃圾回收机制;可以通过Thread的setDemon(true)方法将一个用户线程编程守护线程。

#### 线程的生命周期
线程主要有如下声明周期:新建(NEW)、就绪状态、阻塞状态、等待、超时等待、终结状态。

1.新建状态(NEW)
>* Thread类:继承自Thread(本质上是实现Runnable接口的一个实例),重写run方法,无返回值，启动线程的唯一方法是调用start(native方法)方法。调用start方法就是将线程变成可运行态,什么时候运行由操作系统运行。
>* Runnable接口:实现run方法，无返回值，通过Thread类或者线程池来使用
>* Callable接口:作为FutureTask构造方法函数使用;实现call方法、有返回值、且可以抛出异常;call方法是在Runnable的run方法中被执行的;调用call方法之后,返回future对象,通过调用get方法获取结果时,当前线程会被阻塞，直到call方法调用结束。

2.就绪状态(Runnable):调用新建线程start()方法;不一定会立即执行,可能需要等待CPU分配时间片。

3.阻塞状态(Blocked):调用Object的wait方法后等待同步锁的状态。

4.等待(Waiting):发生在调用以下几个方法时:不带参数的Object.wait();不带参数的Thread.join();LockSupport.park()。

5.超时等待(Timed-Waiting):与wait方法不同的是，会等待指定的一段时间。

6.终止状态(Terminated):当线程运行完毕,即死亡。


#### 停止线程的方法
在Java中，可以调用stop()、suspend()方法来终止线程的执行。
调用stop()方法来终止线程，它会释放已经锁定的所有监视资源。
调用suspend()方法容易发生死锁(suspend不能释放锁)。
可以使用一个标记位来表示线程的状态,通过更改标记位的值来控制线程的终止和运行。


#### 线程死锁的必要条件
>* 互斥条件:资源不能共享,即任一时刻一个资源只能给一个进程使用，其他线程必须等待，直到该资源被占有者释放。
>* 不可剥夺条件:已经分配的资源不能从相应的线程中强制的剥夺,而只能由该资源的进程资源释放。
>* 请求和保持条件:已经申请到的资源可以再次申请新的资源。
>* 循环等待条件:系统中若干进程组成环路,该环路中每个进程都在等待相邻进程正占用资源

预防死锁的方法:合理地对资源进行动态分配,以避免死锁;破坏死锁产生的必要条件。


#### 



start()与run()方法的的区别?
通常,系统通过调用线程类的start()方法来启动一个线程,此时该线程处于就绪状态,而非运行态，也就意味着这个线程可以被JVM来调度执行。JVM通过调用线程类的run()方法来完成实际的操作,当run()方法结束后,此线程就会终止。
start()方法能够异步地调用run()方法，才能真正达到多线程的;但是直接调用run()方法是同步的,因此无法达到多线程的目的。

一个类可以同时继承Thread和实现Runnable接口？
是可以的。从Thread中继承的run()方法,这个继承run()方法可以被当作对Runnable接口的实现，可以通过编译；也可以不使用继承的run方法,而是需要通过在类中重写run()方法来实现Runnable接口中的run方法。

sleep()与wait()方法的区别？
sleep()与wait()都是一种暂停线程的方法。
>* 原理不同:sleep()方法是Thread的静态方法,是线程用来控制自身流程的,它会使此线程暂停执行一段时间,而是把执行机会让给其他线程,等待时间过后,线程自动苏醒;
wait()方法是Object类的方法,用于线程间的通信,这个方法会使当前拥有该对象锁的进程等待,直到其他线程调用notify()方法。
>* 对锁的处理机制不同:调用sleep()方法不会释放锁;调用wait()方法之后,线程会释放它所占用的锁,从而使线程所在对象中的其他synchronized资源被可被其他线程使用。
>* 使用区域不同:wait()方法必须放在同步控制方法或者同步语句块中使用;sleep()方法则是可以放在任何地方。

sleep方法必须捕获异常,有可能会被其他对象调用它的interrupt()，产生InterruptException异常。wait()、notify()、nofityAll()不需要捕获异常。
由于sleep()不需要释放锁标志,容易导致死锁发生,不推荐sleep()方法，推荐wait()方法。

Thread.join()方法的作用？
join()方法是让调用该方法的线程在执行完run()方法之后,然后在执行join()方法后面的代码。就是将两个线程合并，用于实现同步功能。

sleep()和yield()的区别?
Thread.yield()是将当前处于运行状态的线程主动释放占用的CPU资源,转为就绪态,让其他线程执行。
>* sleep()方法给其他线程运行机会时不考虑线程的优先级,因此会给低优先级的线程以运行的机会;yield()方法只给相同优先级或者更高优先级的线程以运行的机会。
>* 线程执行sleep()方法后会转入阻塞状态,所以执行sleeo()方法的线程在指定的时间内肯定不会被执行;yield()方法只是使当前线程重新回到可执行状态,所以执行yield()方法的线程有可能在进入到可执行状态后马上又被执行。
>* sleep()方法声明抛出InterruptedException,而yield()方法没有声明任何异常。
>* sleep()方法比yield()方法具有更好的可移植性。

