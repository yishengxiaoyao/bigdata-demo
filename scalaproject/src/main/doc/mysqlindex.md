# MySQL索引
索引的所用:提高数据查询效率。
常见索引模型:
>* 哈希表:存储键值对;把值放入数组中,用一个哈希函数把key换算成一个确定的位置,然后将value放入数组的这个位置;使用链表处理冲突的问题;适用于等值查询的场景。
>* 有序数组:按照顺序存储;查询用二分法可以快速查询,时间复杂度为O(logN);查询效率高,更新效率低;适用于静态存储引擎。
>* 二叉索引树:每个节点的左儿子小于父节点,父节点小于右儿子;查询时间复杂度为(O(logN)),更新时间复杂度为O(logN);数据库存储大多不适用于二叉树,因为树高过高,会适用N叉树。

InnoDB中的索引模型:B+ 树。

索引类型:
>* 主键索引:叶子节点存的都是整行的数据(聚集索引)
>* 非主键索引:非主键索引的叶子节点内容是主键的值(二级索引)

主键索引与非主键索引的区别:主键索引主要搜索主键的这个B+ 树即可拿到数据。普通索引先搜索索引拿到主键值,再到主键索引树搜索一次(回表)。

一个数据页满了,按照B+树算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率大概降低50%。当相邻的两个数据页利用很低的时候，会做
数据页合并,合并的过程是分类过程的逆过程。

从性能和存储空间方面考量，自增主键往往是更合理的选择。

如何避免长事务对业务的影响？
从应用开发端来看:
>* 确认是否使用了set autocommit = 0。打开MySQL的general_log打开。
>* 确认是否有不必要的只读事务。在读事务中去掉begin/commit 去掉。
>* 业务链接数据库的时候,根据业务本身的预估,通过set max_execution_time命令,来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。

从数据库端来看:
>* 监控information_schema.innodb_trx表,设置事务阈值,超过就报警/或者kill
>* 功能测试时输出general_log,分析日志行为提前发现问题。
>* MySQL 5.6或者更新版本，把innodb_undo_tablesapes设置为2或者更大的值。


由于覆盖索引可减少树的搜索次数,显著提升查询性能,所以使用覆盖索引是一个常用的性能优化手段。

B+ 树这种索引结构,可以利用索引的最左前缀，拉起定位记录。

在建立联合索引的时候,如何安排索引内的字段。
第一原则是如果通过调整顺序,可以少维护一个索引,那么这个顺序往往是需要优先考虑采用的。

MySQL5.6引入的索引下推优化，可以在索引遍历过程中,对索引中包含的字段先做判断,直接过滤掉不满足条件的记录,减少回表次数。