# 数据结构与算法之美
## 数组:为什么很多编程语言中数据都是从0开始
>* 数组是一种线性表的数据结构。它是一组连续的内存结构，来存储一组具有相同类型的数据。
>* 线性表就是数据排成一条线一样的数据，每个线性表上的数据最多只有前和后两个方向。
>* 数组、链表、队列、栈都是线性表结构。二叉树、堆、图都是非线性表结构。
>* 连续的内存空间和相同类型的数据:随机访问。删除和插入操作，就需要做大量的数据搬移工作。
>* 随机访问:一维数组寻找公式:a[k] = base_address + k * data_type_size;二维数组寻找公式:a[i][j]=base_address + (i * n + j) * data_type_size
>* 数组支持随机访问，根据下标随机访问的时间复杂度为O(1),开头插入:最坏时间复杂度为O(n),平均情况时间复杂度是O(n);在中间第K位插入,
时间复杂度为O(1),在末尾插入的时间复杂度为O(1);在开头删除:最坏时间复杂度是O(n),平均时间复杂度为O(n);在中间第K位删除:
每次删除操作只是记录数据已经被删除,当没有更多空间时，才触发执行真正的删除操作;在末尾删除:最好的时间复杂度为O(1)。
插入、删除操作的平均时间复杂度为O(n)。
ArrayList是将数组操作的细节封装起来，并且可以动态扩容(自动扩大1.5倍)。
ArrayList无法存储基本类型。

JVM标记清除算法:在标记阶段，会遍历所有GC ROOTS，
将所有GC ROOTS可达的对象标记为存活，只有当标记工作完成后，
清理工作才会开始。

不足:1.效率问题:标记和清理效率都不高,当少量垃圾产生时会很高效;2.空间问题:会产生不连续的内存空间碎片。

数组访问越界造成无限循环,是编译器的问题。如果内存地址递减的方式，就会造成无限循环。

## 链表
缓存是一种提高数据读取性能的技术。
缓存的大小有限,当缓存满的时候,需要将不需要的数据清除掉。常见的策略有三种:先进先出策略FIFO、最少使用策略(LFU)、最近最少使用策略(LRU)。
链表不需要一块连续的内存空间,通过指针将一组零散的内存块串联起来使用。

数组简单易用,使用连续的内存空间,借助CPU的缓存机制,可以预读数据,所以访问效率更高。
链表在内存中并不是连续存储,对CPU缓存不友好,没方法有效预读。

数据的缺点是大小固定,如果过大,会导致内存不足,如果过小,需要扩容,将数据拷贝到新的数组中,非常耗时。
链表没有大小的限制,天然地支持动态扩容。

链表:通过指针将一组零散的内存块串联起来使用;插入、删除数据非常快速。

单链表:
>* 查找:通过指针一个节点一个节点地一次遍历,知道找到相应的节点;插入、删除数据都非常快速。
>* 插入和删除:只需要考虑相邻节点的指针改变;时间复杂度为O(1)。

循环链表:
>* 概念:一种特殊的单链表;尾指针指向头节点。

双向链表:
>* 概念:支持两个方向,有一个后继指针next指向后面节点,一个前驱指针prev指向前面的节点。查找、删除和插入的效率都比单链表高。
>* 删除等于某个值的节点:从头节点依次遍历对比,直到找到等于给定制的节点，通过指针删除;时间复杂度为O(n)。
>* 删除给定指针指向的节点:遍历节点,找到前驱节点，然后删除，时间复杂度为O(1)。


使用循环链表解决约瑟夫问题。

LinkedHashMap的底层实现为双向链表。

LinkedList的底层实现为双向链表。


使用链表实现LRU(访问的复杂度为O(n))
数组实现的LRU,
或者使用散列表实现LRU。

判断字符串是否为回文字符串,

通过链表判断这个字符串是否为回文字符串。
