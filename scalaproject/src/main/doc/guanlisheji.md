# 管理设计
## 分布式锁
分布式锁的特点:
>* 安全性:在任意时刻，只有一个客户端可以获得锁(排他性)。
>* 避免死锁:客户端最终一定可以获得锁，即使锁往某个资源的客户端在释放锁之前崩溃或者网络不可达。
>* 容错性:只要锁服务集群中的大部分节点存活，Client就可以进行加锁解锁操作。

### Redis分布式锁服务
```
SET resource_name my_random_value NX PX 30000
```
只有在某个key不存在的情况下才能设置成功该key。
```
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```
如果key对应的value一致，则删除这个key(客户端的解锁操作只会解锁自己曾经加锁的资源，是安全的)。

### 分布式锁服务的一个问题
如果在分布式环境中，上面redis的操作，就会有问题。需要引入fence来解决这个问题，就是乐观锁机制，需要一个版本号排他。
如果使用Zookeeper做锁服务的话，使用zxid或者znode的版本号来做这个fence的版本号。

### 从乐观锁到CAS
没更新一次，version就加1。数据库中大多数用的是时间戳。

### 分布式锁设计的重点
分布式锁的特点是:保证在一个集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。

>* 获取锁的进程挂掉了怎么办？在锁服务上添加一个过期时间，如果在这个时间内锁没有被还回来，锁服务自动解锁，以避免全部锁住。

设计分布式锁服务，需要考虑的问题:
>* 需要给一个锁被释放的方式，以避免请求不把锁换回去，导致死锁的问题。Redis使用超时时间，Zookeeper可以依靠自身的sessiontimeout来射出节点。
>* 分布式锁服务应该是高可用的，并且是需要持久化的。
>* 提供分阻塞方式的锁服务。
>* 考虑锁的可重入性。

## 配置中心
### 区分软件的配置
软件的配置分为静态配置(在软件启动时的一些配置，运行时不会进行修改)和动态配置(按照环境分、按照依赖分、按层次分)。

### 配置中心的架构
>* 为什么需要一个变更通知的组件，而不是让配置中心直接推送？原因是分布式环境下，服务器太多，推送不太现实，而采用一个Pub/Sub的通知服务可以让那个数据交换经济一些。
>* 为什么不直接Pub数据过去，还要订阅方反向拉数据？直接推送数据当然可以，使用API来访问的好处:鉴权、调用配置中心的基本API。
>* 配置变更控制器部署在哪里？是在服务器上，还是一个中心的地方？变更配置是一个事务，建议配置变更放在每一台机器上。
>* 平台层的配置变更，有的参数是在服务启动的命令行上，这个怎么变更？一般通过shell做成配置项，通过更新系统环境变量，并重启服务达到配置变更。
>* 操作系统的配置变更和平台层的配置变更最好模块化:有利于维护和减少配置的复杂性。
>* 应用服务配置更新的标准化:通过一个开发框架或者SDK的方式来解决(开发规范，耦合语言);标准运维脚本，让应用方提供变更时的脚本动作；


## 边车模式

边车来实现这些与业务逻辑没有关系的控制功能。

编程的本质就是将控制和逻辑分离和耦合，而边车模式也是异曲同工。

在工程实现sidecar的时候，需要注意一下几个方面:
>* 进程间通讯机制是这个设计的重点，最好使用网络远程调用的方式。