# Java代码是如何运行的

## 为什么Java要在虚拟机里运行
JRE:Java的运行时环境。
JRE仅包含运行Java程序的必须组件,包括Java虚拟机以及Java核心类库等。
Java虚拟机是将Java代码转换为字节码。
Java虚拟机可以有硬件实现,也可以用软件实现。使用软件实现的好处,一旦一个程序被转换为Java字节码,那么它便可以在不同平台上的虚拟机实现里运行。
虚拟机的另外一个好处:托管环境,自动内存管理与垃圾回收。

## Java虚拟机具体是怎样运行Java字节码

### 虚拟机
从虚拟机的角度来看,执行Java代码首先需要将它编译而成的class文件加载到java虚拟机中。
加载后的Java类会被存放于方法区。实际运行时,虚拟机会执行方法区内的代码。
Java虚拟机在内存中划分出堆和栈来存储运行时数据。Java虚拟机会将栈细分为面向Java方法的Java方法栈(存放局部变量以及字节码的操作数)、
面向本地方法栈、以及存放各个线程执行位置的PC寄存器。

从硬件角度来看,Java虚拟机需要将字节码翻译成机器码。
解释执行:即逐条将字节码翻译成机器码并执行(无需等待编译)。即时编译:即将一个方法中包含的所有字节码编译成机器码后在执行(实际运行速度更快)。
HotSpot默认采用混合模式,先解释执行字节码,而后将其中反复执行的热点代码,以方法为单位进行即时编译。

## Java虚拟机的运行效率是怎么样的

HotSpot提供了C1、C2和Graal(Java10)编译器。

C1又叫做Client编译器,面向的是对启动性能有要求的客户端GUI程序,采用的优化手段相对简单,因此编译时间较短。
C2又叫做Server编译器,面向的是对峰值性能又要求的服务端程序，采用的优化手段相对复杂,因此编译时间较长。

从Java7开始,HotSpot默认采用分层编译的方式:热点方法会先被C1编译,而后热点方法中的热点会进一步被C2编译。
HotSpot的即时编译是放在额外的编译线程中进行的。HotSpot会根据CPU的数量设置编译线程的数目,并且按1:2的比例
配置为C1和C2编译器。

Java虚拟机会将boolean类型看作是int类型。true就是1,false是0。


|类型|值域|默认值|虚拟机内部符号|
|----|----|----|----|
|boolean|{false,true}|false|Z|
|byte|[-128,127]|0|B|
|short|[-32768,32767]|0|S|
|char|[0,65535]|'\u0000'|C|
|int|[-2^31,2^31-1]|0|I|
|long|[-2^63,2^63-1]|0L|J|
|float|~[-3.4E38,3.4E38]|+0.0F|F|
|double|~[1.8E308,1.8E308]|+0.0D|D|

不管何种类型,拥有不同的值域,但默认值在内存中均为0。

声明为byte、char以及short的局部变量,是可以存储超过它们取值范围的数值,在存储的时候,Java虚拟机会进行掩码操作。
在读取时,Java虚拟机则会将其扩展为int类型。

将boolean保存在静态域中,制定了其类型为'Z',当修改为2时取低位最后一位为0,当修改为3时取低位最后一位为1。
说明boolean的掩码处理是取低位的最后一位。



## Java虚拟机是如何加载Java类

Java语言的类型可以分为两大类:基本类型和引用类型。Java将其细分为四种:类、接口、数组类和泛型参数。由于泛型参数会在编译过程中被擦除。
在类、接口和数组类中,数组类是由Java虚拟机直接生成的,其他两种则有对应的字节流。

### 加载
加载是指查找字节流,并且据此创建类的过程。对于数组类来说,它并没有对应的字节流,而是Java虚拟机直接生成的。对于其他的类来说,
Java虚拟机则需要借助类加载起来完成查找字节流的过程。

启动类加载(Bootstrap Loader)是由C++实现的,没有对应的Java对象,因此在Java中只能用null来替代。
除了Bootstrap Loader之外,其他的类加载器都是java.lang.ClassLoader的子类,因为有对应的Java对象。这些类加载器需要先有
Bootstrap Loader,加载至Java虚拟机中,方能执行类加载。

JVM使用的是双亲委派模型:每当一个类加载接收到加载请求时,它会将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下,该类
加载器才会尝试取加载。

Java 9 之前,Bootstrap Loader负责加载最为基础、最为重要的类(jre/lib/rt.jar的类);
ExtClassLoader负责加载扩展类(jar/lib/ext/*.jar的类);AppClassLoader负责加载应用类(classpath制定的目录或jar中的类)。

类的加载方式分为隐士加载和显示加载。隐士加载指的是程序在使用new等方式创建对象时,会隐士地调用类的加载器把对应的类加载到JVM中。
显示加载指的是通过直接调用Class.forName()方法来把所需的类加载到JVM中。

Java语言中,类的加载是动态的,它并不会一次性将所有类全部加载后再运行,而是保证程序运行的基础类完全加载到JVM中,至于其他类,在需要时才加载。

在Java虚拟机中,类的唯一性是由类加载器实例以及类的全名一同确定,即便是同一串字节流,经由不同的类加载器加载,也会得到两个不同的类。

### 链接
链接是指将创建成的类合并至Java虚拟机中,使之能够执行的过程。可以分为验证、准备以及解析三个阶段。

验证阶段的目的,在于确保被加载类能够满足Java虚拟机的约束条件。

准备阶段的目的,则是为被加载类的静态字段分配内存。

解析阶段的目的,将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类,或者未被加载的字段或方法,那么解析将触发这个类的加载。

Java虚拟机规范并没有要求在链接过程中完成解析。

### 初始化

在Java代码中,如果要初始化一个静态字段,可以声明时直接赋值,也可以在静态代码块中对其赋值。
如果直接赋值的静态字段被final所修饰,并且它的类型是基本类型或字符串时,那么该字段便会被Java编译器标记成常量值,
其初始化直接由Java虚拟机完成。除此之外的直接赋值操作,所以所有静态代码块中的代码,则会被Java编译器置于同一方法中,并把它命名为<clinit>。
类加载的最后一步是初始化,便是为标记为常量值的字段赋值,以及执行<clinit>方法的过程。Java虚拟机会通过加锁来确保类的<clinit>方法仅被执行一次。

那种方式可以触发初始化:
>* 当虚拟机启动时,初始化用户制定的主类;
>* 当遇到用以新建目标类实例的new指令时,初始化new指令的目标类;
>* 当遇到调用静态方法的指令时,初始化该静态方法所在的类;
>* 当遇到访问静态字段的指令时,初始化该静态字段所在的类;
>* 子类的初始化会触发父类的初始化;
>* 如果一个接口定义了default方法,那么直接实现或者间接实现该接口的类的初始化,会触发该接口的初始化;
>* 使用反射API对莫个类进行反射调用时,初始化这个类;
>* 当初次调用MethodHandle实例时,初始化该MethodHandle指向的方法所在的类。

由于类初始化是线程安全的,并且仅按被执行一次,因此程序可以确保多线程环境下有且仅有一个Singleton实例。

在创建对象时,不会初始化元素;在调用时,才会真正链接和初始化。


